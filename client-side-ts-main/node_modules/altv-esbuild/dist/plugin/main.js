var w=Object.defineProperty;var B=(s,e,t)=>e in s?w(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var m=(s,e,t)=>(B(s,typeof e!="symbol"?e+"":e,t),t);var h={mode:"client",dev:{enabled:!0,hotReload:!0,hotReloadServerPort:8877,hotReloadServerHost:"",playersReconnect:!0,playersReconnectDelay:200,playersReconnectResetPos:!0,connectionCompleteEvent:!0,disconnectEvent:!0,restartCommand:!0,topLevelExceptionHandling:!0,moveExternalsOnTop:!0,enhancedRestartCommand:!1,serverStartedEvent:!0,clientServerInstanceValidation:!1},bugFixes:{webViewFlickering:!0,playerPrototype:!0},altvEnums:!1,enhancedAltLog:!0,altDefaultImport:!1};var $=({mode:s,dev:e,bugFixes:t,altvEnums:n,enhancedAltLog:r,altDefaultImport:o})=>{if(typeof s==null)throw new Error('mode option must be provided: "server" or "client"');return e??=!1,{mode:s,dev:e===!0?{...h.dev,enabled:!0}:T(e)?{...Object.fromEntries(Object.entries(h.dev).map(([i,a])=>[i,typeof a=="boolean"?!1:typeof a=="string"?"":-1])),enabled:!1}:{...h.dev,...e,playersReconnectResetPos:e.playersReconnectResetPos??e.playersReconnect??h.dev.playersReconnectResetPos},bugFixes:t===!0?h.bugFixes:{...h.bugFixes,...t},altvEnums:n??h.altvEnums,enhancedAltLog:r??h.enhancedAltLog,altDefaultImport:o??h.altDefaultImport}};function T(s){return s===!1||s.enabled===!1}var c="altv-esbuild";var f=class{receiver;sender;constructor(e,t,n){this.isCommunicatorSenderAndReceiver(e)?(this.sender=e.sender??null,this.receiver=e.receiver??null):(this.sender=e,this.receiver=e),this.receiver?.on("data",r=>{r=r.toString();for(let o of r.split("|"))if(o)try{let{event:i,args:a}=JSON.parse(o),_=t[i];if(!_){n(`received unknown event: ${i}`);return}_(...a)}catch(i){n(`failed to handle chunk: '${o}' error: ${i?.stack}`)}}),this.receiver?.on("error",r=>{r?.code==="ECONNRESET"||r?.code==="ECONNREFUSED"||n(`socket error: ${r.stack}`,r)})}send(e,...t){if(!this.sender)throw new Error("EventManager cannot send since sender was not provided");let n={args:t,event:e};this.sender.write(JSON.stringify(n)+"|")}destroy(){this.receiver?.removeAllListeners("data"),this.receiver?.removeAllListeners("error")}isCommunicatorSenderAndReceiver(e){return!!(e.sender||e.receiver)}};var b=class{constructor(e){this.name=e;this.debug=()=>{}}debug;info(...e){console.log(`${b.CONSOLE_BLUE}[${c}][${this.name}]${b.CONSOLE_RESET}`,...e)}error(...e){console.error(`${b.CONSOLE_RED}[ERROR] [${c}][${this.name}]`,...e)}},d=b;m(d,"CONSOLE_BLUE","\x1B[34m"),m(d,"CONSOLE_RESET","\x1B[0m"),m(d,"CONSOLE_RED","\x1B[31m");var p=s=>"___altvEsbuild_"+s.replace(/[-/\\ @.:]/g,"_x_")+"___";import N from"fs";import M from"path";var u=p("altvInject_altShared"),v=p("altvInject_alt"),O=p("altvInject_native"),y=(n=>(n[n.None=0]="None",n[n.Start=1]="Start",n[n.End=2]="End",n))(y||{});var E=class{constructor(e,t){this.options=e;this.build=t;this._log=new d(`shared: ${e.mode}`),this.addExternalImportHandling(t,"alt-shared",u),this.addExternalImportHandling(t,"alt",v),e.altvEnums&&this.addCustomModule(t,"altv-enums",N.readFileSync(new URL("../../altv-enums/dist/enums.js",import.meta.url)).toString())}_log;bannerImportsCode=`// banner imports
`;handleBuildOptions(){let{banner:e,footer:t,external:n}=this.build.initialOptions,r={banner:{...e,js:e?.js??""},footer:{...t,js:t?.js??""},external:n?[...n]:[]};if(this.bannerImportsCode+=`const ${p("altvInject_pluginOptions")} = ${JSON.stringify(this.options)};
`,this.options.dev.enhancedRestartCommand){let a=import.meta.url.slice(8);a=M.join(a,"../../"),a=a.replaceAll("\\","/"),this._log.debug({pluginDistDir:a}),this.bannerImportsCode+=`const ${p("altvInject_pluginDistDir")} = "${a}";
`}let o=r.external.indexOf("alt"),i=r.external.indexOf("alt-shared");return o!==-1&&r.external.splice(o,1),i!==-1&&r.external.splice(i,1),r}endBannerJs(e){let t="";this.options.dev.topLevelExceptionHandling&&(t+="try {"),e.banner.js+=`// ------------------- ${c} banner -------------------
`+this.bannerImportsCode+`await (async () => { // start banner wrapper
`+N.readFileSync(new URL("../altv-inject/main.js",import.meta.url)).toString()+`})().catch(e => ${u}.logError("[altv-esbuild] banner wrapper error:", e?.stack ?? e?.message ?? e));
`+t+`// ------------------- ${c} banner -------------------
`}endFooterJs(e){let t="";this.options.dev.topLevelExceptionHandling&&(t+=`} catch (e) {
        const error = ${u}.logError;

        // hide all other user logs to show error at a glance
        ${u}.log = () => {};
        ${u}.logWarning = () => {};
        ${u}.logError = () => {};
        ${v}.log = () => {};
        ${v}.logWarning = () => {};
        ${v}.logError = () => {};
        console.log = () => {};
        console.warn = () => {};
        console.error = () => {};

        ${u}.setTimeout(() => {
          error(
            "[${c}] Top-level exception:\\n  ",
            e?.stack ?? e
          );
        }, 500);
        if (${v}.isClient) {
          drawError("TOP-LEVEL EXCEPTION", "see client console", "(it's message from altv-esbuild)");
          function drawError(title,text,text2){
            const alt = ${v};
            alt.addGxtText("warning_error",title);
            alt.addGxtText("warning_text",text);
            alt.addGxtText("warning_text2",text2);
            let state=!alt.isConsoleOpen();
            const timeout=alt.setInterval(()=>{state=!alt.isConsoleOpen()},50);
            const tick=alt.everyTick(()=>{
              if (state) {
                ${O}.setWarningMessageWithHeader(
                  "warning_error",
                  "warning_text",
                  0,
                  "warning_text2",
                  false, -1,
                  null, null,
                  true, 0
                );
              }
            });
            return()=>{alt.clearInterval(timeout);alt.clearEveryTick(tick)}
          }
        }
      }`),e.footer.js+=`
// ------------------- ${c} footer -------------------
`+t+`
// ------------------- ${c} footer -------------------
`}addExternalImportHandling(e,t,n){let r=`${c}:external-handling-${t}`;this.bannerImportsCode.includes(`import ${n} from`)||(this.bannerImportsCode+=`import ${n} from "${t}";
`),e.onResolve({filter:new RegExp(`^${t}$`)},i=>({path:i.path,namespace:r}));let o=this.options.altDefaultImport;e.onLoad({filter:/.*/,namespace:r},()=>({contents:o?`export default ${n}`:`module.exports = ${n}`}))}addCustomModule(e,t,n){let r=`${c}:custom-module-${t}`;e.onResolve({filter:new RegExp(`^${t}$`)},i=>({path:i.path,namespace:r}));let o=typeof n=="string"?()=>n:n;e.onLoad({filter:/.*/,namespace:r},()=>({contents:o(),loader:"js"}))}enableMoveExternalImportsOnTop({external:e},t,n,r,o){let i=`${c}:externals-on-top`,a=[...e,...t??[]].join("|"),_={};this.bannerImportsCode+=`// ----------------- external imports on top -----------------
`,n&&(this.bannerImportsCode+=`// ----------- additional top -----------
`,this.bannerImportsCode+=n,this.bannerImportsCode+=`// ----------- additional top -----------
`);for(let l of e){if(l.includes("*")){let x=`external name: ${l} "*" wildcard character is not supported yet`;throw this._log.error(x),this._log.error("(this error came from plugin option moveExternalsOnTop"),this._log.error("that can be disabled if you are not using externals with enabled topLevelExceptionHandling)"),new Error(x)}let g=p(`externalOnTop_${l}`);_[l]=g,this.bannerImportsCode+=`import * as ${g} from "${l}";
`}for(let l of t??[])_[l]=p(`additional_externalOnTop_${l}`);this.bannerImportsCode+=`// ----------------- external imports on top -----------------
`,this.build.onResolve({filter:new RegExp(`^(${a}|${o}.+)$`)},({path:l})=>{if(o&&l.startsWith(o))return this._log.debug("import additionalExternalStart path:",l),{path:l,namespace:i,pluginData:null};let g=p(`externalOnTop_${l}`);if(!g){let x=`external: ${l} var name not found`;throw this._log.error(x),new Error(x)}return{path:l,namespace:i,pluginData:g}}),this.build.onLoad({filter:/.*/,namespace:i},({pluginData:l,path:g})=>({contents:r?.(g,l??null)??`
            Object.defineProperty(exports, '__esModule', { value: true })
            for (const key in ${l}) {
              exports[key] = ${l}[key]
            }
        `}))}};import L from"net";var I=class{constructor(e,t,n,r,o){this.name=e;this._net=t;this.port=n;this.host=r;this.connectHandler=o;this._socket=this.connect()}logDebug=()=>{};onError=e=>{(e?.code==="ECONNRESET"||e?.code==="ECONNREFUSED")&&(this.logDebug(`disconnected from server, trying reconnecting in ${I.RECONNECT_MS}ms...`),setTimeout(()=>this.connect(),I.RECONNECT_MS))};onConnect=e=>{this.connectHandler(e)};_socket;get socket(){return this._socket}connect(){this._socket&&this._socket.destroy();let e=this._net.connect(this.port,this.host===""?void 0:this.host);return e.on("connect",this.onConnect.bind(this,e)),e.on("error",this.onError),e}},S=I;m(S,"RECONNECT_MS",500);var k=class extends E{events={buildEnd:()=>{},buildStart:()=>{},clientConnect:()=>{},clientDisconnect:()=>{}};onConnect=()=>{this.log.info("connected to server"),this.eventManager?.send("connect","client")};log=new d("client");socket;eventManager;socketConnect;constructor(e,t){super(e,t);let{dev:n}=e;n.hotReload&&(this.socketConnect=new S("plugin-client",L,this.options.dev.hotReloadServerPort,this.options.dev.hotReloadServerHost,r=>{this.socket=r,this.eventManager=new f(this.socket,this.events,o=>this.log.error("[events]",o)),this.onConnect()}),t.onStart(()=>{this.eventManager?.send("clientBuildStart")}),t.onEnd(({errors:r})=>{if(r.length){this.log.debug("client build end errors");return}this.eventManager?.send("clientBuildEnd")})),this.addExternalImportHandling(t,"alt-client",v),this.addExternalImportHandling(t,"natives",O)}handleBuildOptions(){let e=super.handleBuildOptions(),t=e.external.indexOf("alt-client");t!==-1&&e.external.splice(t,1);let n=e.external.indexOf("natives");return n!==-1&&e.external.splice(n,1),this.options.dev.moveExternalsOnTop&&this.enableMoveExternalImportsOnTop(e),this.endBannerJs(e),this.endFooterJs(e),e}};import A from"net";var R=class{constructor(e,t,n,r,o,i){this.mode=e;this.port=t;this.host=n;this.connectModeHandler=r;this.clientBuildStartHandler=o;this.clientBuildEndHandler=i;this.tryListen(t,n),this.server.on("error",this.onError),this.server.on("listening",this.onStartListening),this.onErrorAddrInUse=()=>{this.log.error("port:",this.port,"already in use"),process.exit()}}onStartListening=()=>{this.log.info("started listening on port:",this.port)};onConnect=e=>{this.log.debug("some client connected");let t="unknown",n=new f(e,{connect:r=>{if(this._sockets[r]){this.log.error(`another socket mode: ${r} is connected currently`),e.destroy(),n.destroy();return}t=r,this.log.info(`connected socket mode: ${r}`),this._sockets[r]={socket:e,eventManager:n},e.on("close",this.onSocketClose.bind(this,r)),(r==="client"||r==="server"&&this._sockets.client)&&this._sockets.server?.eventManager.send("clientConnect"),this.connectModeHandler(r)},clientBuildStart:()=>{this.clientBuildStartHandler()},clientBuildEnd:()=>{this.clientBuildEndHandler()}},(r,o)=>this.onSocketError(t,r,o))};onError=e=>{e.code==="EADDRINUSE"&&this.onErrorAddrInUse(),this.log.error("server error:",e)};onSocketError=(e,t,n)=>{if(n?.code==="ECONNRESET"){this.log.debug(`disconnected socket mode: ${e}`);return}this.log.error(`socket mode: ${e} error:`,n)};onSocketClose=e=>{this._sockets[e]?.eventManager.destroy(),this._sockets[e]=null,this.log.info(`disconnected socket mode: ${e}`)};log=new d("NetServer");server=new A.Server(this.onConnect);onErrorAddrInUse;_sockets={client:null,server:null};get sockets(){return this._sockets}sendEvent(e,t,...n){let r=this._sockets[e];if(!r){this.log.error(`[sendEvent] event: ${t} no target socket mode: ${e}`);return}r.eventManager.send(t,...n)}tryListen(e,t){this.server.listen(e,t===""?void 0:t)}};var P=["_http_agent","_http_client","_http_common","_http_incoming","_http_outgoing","_http_server","_stream_duplex","_stream_passthrough","_stream_readable","_stream_transform","_stream_wrap","_stream_writable","_tls_common","_tls_wrap","assert","assert/strict","async_hooks","buffer","child_process","cluster","console","constants","crypto","dgram","diagnostics_channel","dns","dns/promises","domain","events","fs","fs/promises","http","http2","https","inspector","module","net","os","path","path/posix","path/win32","perf_hooks","process","punycode","querystring","readline","repl","stream","stream/consumers","stream/promises","stream/web","string_decoder","sys","timers","timers/promises","tls","trace_events","tty","url","util","util/types","v8","vm","wasi","worker_threads","zlib"];var C=class extends E{hotReloadServer;log=new d("server");cachedBuildState={client:0,server:0};wasConnectedOnce={client:!1,server:!1};onConnectSomeMode=e=>{if(!this.wasConnectedOnce[e]){this.wasConnectedOnce[e]=!0;return}let t=this.cachedBuildState[e];if(t!==0){switch(this.log.debug("onConnectSomeMode:",e,"-> sending cached build event:",y[t]),t){case 1:this.sendBuildStart(e,!0);break;case 2:this.sendBuildEnd(e,!0);break}this.cachedBuildState[e]=0}};onClientBuildStart=()=>{if(this.log.debug("onClientBuildStart"),this.cacheBuildStateIfNeeded("client",2)){this.log.debug("onClientBuildStart but server socket is not connected -> send it on connect");return}this.hotReloadServer?.sockets.server&&(this.log.debug("onClientBuildStart, send server altv-inject buildStart event"),this.sendBuildStart("client"))};onClientBuildEnd=()=>{if(this.log.debug("onClientBuildEnd"),this.cacheBuildStateIfNeeded("client",2)){this.log.debug("onClientBuildEnd but server socket is not connected -> send it on connect");return}this.hotReloadServer?.sockets.server&&(this.log.debug("onClientBuildEnd, send server altv-inject BuildEnd event"),this.sendBuildEnd("client"))};constructor(e,t){super(e,t);let{mode:n,dev:r}=e;if(r.enabled&&r.hotReload){let o=new R(n,r.hotReloadServerPort,r.hotReloadServerHost,this.onConnectSomeMode,this.onClientBuildStart,this.onClientBuildEnd);this.hotReloadServer=o;let i=this.cacheBuildStateIfNeeded.bind(this,"server");t.onEnd(({errors:a})=>{if(a.length){this.log.debug("build.onEnd errors");return}if(this.log.debug("server buildEnd"),i(2)){this.log.debug("buildEnd but server socket is not connected -> send it on connect");return}o.sockets.server&&(this.log.debug("send buildEnd"),this.sendBuildEnd("server"))}),t.onStart(()=>{if(i(1)){this.log.debug("buildStart but server socket is not connected -> send it on connect");return}o.sockets.server&&(this.log.debug("send buildStart"),this.sendBuildStart("server"))})}this.addExternalImportHandling(t,"alt-server",v)}handleBuildOptions(){let e=super.handleBuildOptions(),t=e.external.indexOf("alt-server");if(t!==-1&&e.external.splice(t,1),this.options.dev.moveExternalsOnTop){let n=p("createRequire"),r=p("customRequire");this.enableMoveExternalImportsOnTop(e,P,`import { createRequire as ${n} } from 'module';
const ${r} = ${n}(import.meta.url);
`,(o,i)=>`
            try {
              module.exports = ${r}('${o}')
            } catch (e) {
              ${i?`
                        if (!(
                          e.code === 'ERR_REQUIRE_ESM' ||
                          e.code === 'MODULE_NOT_FOUND' // altv resource import error fix
                        )) {
                          try {
                            ${u}.nextTick(() => ${u}.logError(e?.stack))
                          } catch {}
                        }
                        Object.defineProperty(exports, '__esModule', { value: true })
                        for (const key in ${i}) {
                          exports[key] = ${i}[key]
                        }`:`${u}.nextTick(() => ${u}.logError("Failed to import nodejs built in module name: '${o}'", e?.stack))`}
              }
        `,"node:")}return this.endBannerJs(e),this.endFooterJs(e),e}sendBuildStart(e,t=!1){this.hotReloadServer?.sendEvent("server","buildStart",e,t)}sendBuildEnd(e,t=!1){this.hotReloadServer?.sendEvent("server","buildEnd",e,t)}cacheBuildStateIfNeeded(e,t){return this.hotReloadServer?.sockets.server||!this.wasConnectedOnce[e]?!1:this.cachedBuildState[e]===t?(this.log.debug("[cacheBuildStateIfNeeded] mode:",e,y[t],"already cached"),!0):(this.log.debug("cache mode:",e,"buildState:",y[t]),this.cachedBuildState[e]=t,!0)}};var et=s=>{let e=$(s);return new d("plugin").debug("merged options:",e),{name:c,setup(n){let{initialOptions:r}=n,i=(e.mode==="client"?new k(e,n):new C(e,n)).handleBuildOptions();Object.assign(r,i)}}};export{et as altvEsbuild};
